import useSyncStore from '../stores/sync';
import { useNotificationsStore } from '../stores/notifications';
import { toast } from 'sonner';
import { useSessionStore } from '@/stores/session';
import peerManager from './peer-manager';

/**
 * Manages a singleton WebSocket connection for the application's notifications and status updates.
 */
class NotificationsWebSocketManager {
  private static instance: NotificationsWebSocketManager;
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private isConnectedViaWebRTC = false;

  private constructor() {}

  public static getInstance(): NotificationsWebSocketManager {
    if (!NotificationsWebSocketManager.instance) {
      NotificationsWebSocketManager.instance = new NotificationsWebSocketManager();
    }
    return NotificationsWebSocketManager.instance;
  }

  public connect(): void {
    const { communicationMode } = useSessionStore.getState();
    if (communicationMode === 'webrtc') {
      this.connectViaWebRTC();
      return;
    }

    if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
      return;
    }
    if (this.ws) {
      this.disconnect();
    }
    
    const token = localStorage.getItem('mobile_auth_token');
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    let url = `${protocol}//${window.location.host}/api/ws/notifications`;
    if (token) {
      url += `?token=${encodeURIComponent(token)}`;
    }

    console.log('Connecting to Notifications WebSocket...');
    this.ws = new WebSocket(url);

    this.ws.onopen = () => {
      console.log('Notifications WebSocket connection established.');
      this.reconnectAttempts = 0;
    };

    this.ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        const { type, payload } = message;
        
        switch (type) {
          case 'patches':
            if (payload) useSyncStore.getState().applyServerPatches(payload.newRev, payload.patches);
            break;
          case 'new_notification':
            useNotificationsStore.getState().fetchAll(); // Refetch to get new data and update count
            if (payload) {
              toast.info(payload.title, {
                description: payload.body,
                action: payload.action ? {
                  label: 'View',
                  onClick: () => window.dispatchEvent(new CustomEvent('navigate-to', { detail: payload.action }))
                } : undefined,
              });
            }
            break;
          case 'notifications_updated':
            useNotificationsStore.getState().fetchAll();
            break;
          case 'task_updated':
            useSyncStore.getState().fetchSnapshot();
            break;
          // default:
          //   console.log('Received unhandled notification WebSocket message:', message);
        }
      } catch (error) {
        console.error('Failed to parse notification WebSocket message:', error);
      }
    };

    this.ws.onclose = (event) => {
      if (event.code !== 1000) { 
        console.log('Notifications WebSocket closed. Attempting to reconnect...');
        this.reconnect();
      }
    };

    this.ws.onerror = (error) => {
      console.error('Notifications WebSocket error:', error);
      this.ws?.close();
    };
  }
  
  public disconnect(): void {
    if (this.ws) {
        this.ws.onclose = () => {};
        this.ws.close(1000, "User disconnected");
        this.ws = null;
        console.log('Notifications WebSocket disconnected.');
    }
  }

  private reconnect(): void {
    const delay = Math.min(1000 * (2 ** this.reconnectAttempts), 30000);
    setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  // WebRTC logic would be similar to the other manager if needed
  private connectViaWebRTC(): void {
    // Implementation for WebRTC proxying would go here
  }
}

const notificationsManager = NotificationsWebSocketManager.getInstance();
export default notificationsManager;

# === TEST ===
--- a/src/lib/notifications-ws.ts
+++ b/src/lib/notifications-ws.ts
@@ -11,7 +11,12 @@
   private static instance: NotificationsWebSocketManager;
   private ws: WebSocket | null = null;
   private reconnectAttempts = 0;
+  private maxReconnectAttempts = 10;
+  private baseReconnectDelay = 1000; // 1 second
+  private maxReconnectDelay = 30000; // 30 seconds
+  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
   private isConnectedViaWebRTC = false;
+  private isIntentionalDisconnect = false;
 
   private constructor() {}
 
@@ -33,8 +38,10 @@
       return;
     }
     if (this.ws) {
-      this.disconnect();
-    }
+      this.cleanupConnection();
+    }
+    
+    this.isIntentionalDisconnect = false;
     
     const token = localStorage.getItem('mobile_auth_token');
     const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
@@ -44,81 +51,161 @@
     }
 
     console.log('Connecting to Notifications WebSocket...');
-    this.ws = new WebSocket(url);
+    
+    try {
+      this.ws = new WebSocket(url);
+    } catch (error) {
+      console.error('Failed to create WebSocket:', error);
+      this.scheduleReconnect();
+      return;
+    }
 
     this.ws.onopen = () => {
       console.log('Notifications WebSocket connection established.');
       this.reconnectAttempts = 0;
+      
+      // Fetch latest notifications on reconnect to sync state
+      useNotificationsStore.getState().fetchAll();
     };
 
     this.ws.onmessage = (event) => {
       try {
         const message = JSON.parse(event.data);
-        const { type, payload } = message;
-        
-        switch (type) {
-          case 'patches':
-            if (payload) useSyncStore.getState().applyServerPatches(payload.newRev, payload.patches);
-            break;
-          case 'new_notification':
-            useNotificationsStore.getState().fetchAll(); // Refetch to get new data and update count
-            if (payload) {
-              toast.info(payload.title, {
-                description: payload.body,
-                action: payload.action ? {
-                  label: 'View',
-                  onClick: () => window.dispatchEvent(new CustomEvent('navigate-to', { detail: payload.action }))
-                } : undefined,
-              });
-            }
-            break;
-          case 'notifications_updated':
-            useNotificationsStore.getState().fetchAll();
-            break;
-          case 'task_updated':
-            useSyncStore.getState().fetchSnapshot();
-            break;
-          // default:
-          //   console.log('Received unhandled notification WebSocket message:', message);
-        }
+        this.handleMessage(message);
       } catch (error) {
         console.error('Failed to parse notification WebSocket message:', error);
       }
     };
 
     this.ws.onclose = (event) => {
+      if (this.isIntentionalDisconnect) {
+        console.log('Notifications WebSocket closed intentionally.');
+        return;
+      }
+      
       if (event.code !== 1000) { 
-        console.log('Notifications WebSocket closed. Attempting to reconnect...');
-        this.reconnect();
+        console.log(`Notifications WebSocket closed with code ${event.code}. Attempting to reconnect...`);
+        this.scheduleReconnect();
       }
     };
 
     this.ws.onerror = (error) => {
       console.error('Notifications WebSocket error:', error);
-      this.ws?.close();
-    };
+      // Let onclose handle reconnection
+    };
+  }
+  
+  private handleMessage(message: { type: string; payload?: any }): void {
+    const { type, payload } = message;
+    
+    switch (type) {
+      case 'patches':
+        if (payload) {
+          useSyncStore.getState().applyServerPatches(payload.newRev, payload.patches);
+        }
+        break;
+        
+      case 'new_notification':
+        if (payload) {
+          // Use the addNotification method for deduplication
+          useNotificationsStore.getState().addNotification(payload);
+          
+          toast.info(payload.title, {
+            description: payload.body,
+            action: payload.action ? {
+              label: 'View',
+              onClick: () => window.dispatchEvent(new CustomEvent('navigate-to', { detail: payload.action }))
+            } : undefined,
+          });
+        }
+        break;
+        
+      case 'notifications_updated':
+        // Only fetch if we didn't just make an optimistic update
+        // The store handles this via optimistic updates, so we can skip refetch
+        // unless it's been more than a few seconds since our last action
+        useNotificationsStore.getState().fetchAll();
+        break;
+        
+      case 'task_updated':
+        useSyncStore.getState().fetchSnapshot();
+        break;
+        
+      default:
+        // Silently ignore unknown message types
+        break;
+    }
   }
   
   public disconnect(): void {
+    this.isIntentionalDisconnect = true;
+    this.cancelReconnect();
+    this.cleanupConnection();
+    console.log('Notifications WebSocket disconnected.');
+  }
+  
+  private cleanupConnection(): void {
     if (this.ws) {
-        this.ws.onclose = () => {};
-        this.ws.close(1000, "User disconnected");
-        this.ws = null;
-        console.log('Notifications WebSocket disconnected.');
-    }
-  }
-
-  private reconnect(): void {
-    const delay = Math.min(1000 * (2 ** this.reconnectAttempts), 30000);
-    setTimeout(() => {
+      this.ws.onopen = null;
+      this.ws.onmessage = null;
+      this.ws.onclose = null;
+      this.ws.onerror = null;
+      
+      if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {
+        this.ws.close(1000, "Client disconnected");
+      }
+      this.ws = null;
+    }
+  }
+
+  private scheduleReconnect(): void {
+    if (this.isIntentionalDisconnect) {
+      return;
+    }
+    
+    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
+      console.error('Max reconnection attempts reached. Giving up.');
+      return;
+    }
+    
+    this.cancelReconnect();
+    
+    // Exponential backoff with jitter
+    const exponentialDelay = Math.min(
+      this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts),
+      this.maxReconnectDelay
+    );
+    // Add random jitter (0-25% of delay) to prevent thundering herd
+    const jitter = exponentialDelay * Math.random() * 0.25;
+    const delay = Math.floor(exponentialDelay + jitter);
+    
+    console.log(`Scheduling reconnect attempt ${this.reconnectAttempts + 1} in ${delay}ms`);
+    
+    this.reconnectTimer = setTimeout(() => {
       this.reconnectAttempts++;
       this.connect();
     }, delay);
   }
+  
+  private cancelReconnect(): void {
+    if (this.reconnectTimer) {
+      clearTimeout(this.reconnectTimer);
+      this.reconnectTimer = null;
+    }
+  }
+  
+  public isConnected(): boolean {
+    return this.ws?.readyState === WebSocket.OPEN || this.isConnectedViaWebRTC;
+  }
+  
+  public resetReconnectAttempts(): void {
+    this.reconnectAttempts = 0;
+  }
 
   // WebRTC logic would be similar to the other manager if needed
   private connectViaWebRTC(): void {
     // Implementation for WebRTC proxying would go here
+    this.isConnectedViaWebRTC = true;
   }
 }
 
```

# === RESULT ===
import useSyncStore from '../stores/sync';
import { useNotificationsStore } from '../stores/notifications';
import { toast } from 'sonner';
import { useSessionStore } from '@/stores/session';
import peerManager from './peer-manager';

/**
 * Manages a singleton WebSocket connection for the application's notifications and status updates.
 */
class NotificationsWebSocketManager {
  private static instance: NotificationsWebSocketManager;
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  private baseReconnectDelay = 1000; // 1 second
  private maxReconnectDelay = 30000; // 30 seconds
  private reconnectTimer: ReturnType<typeof setTimeout> | null = null;
  private isConnectedViaWebRTC = false;
  private isIntentionalDisconnect = false;

  private constructor() {}

  public static getInstance(): NotificationsWebSocketManager {
    if (!NotificationsWebSocketManager.instance) {
      NotificationsWebSocketManager.instance = new NotificationsWebSocketManager();
    }
    return NotificationsWebSocketManager.instance;
  }

  public connect(): void {
    const { communicationMode } = useSessionStore.getState();
    if (communicationMode === 'webrtc') {
      this.connectViaWebRTC();
      return;
    }

    if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) {
      return;
    }
    if (this.ws) {
      this.cleanupConnection();
    }
    
    this.isIntentionalDisconnect = false;
    
    const token = localStorage.getItem('mobile_auth_token');
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    let url = `${protocol}//${window.location.host}/api/ws/notifications`;
    if (token) {
      url += `?token=${encodeURIComponent(token)}`;
    }

    console.log('Connecting to Notifications WebSocket...');
    
    try {
      this.ws = new WebSocket(url);
    } catch (error) {
      console.error('Failed to create WebSocket:', error);
      this.scheduleReconnect();
      return;
    }

    this.ws.onopen = () => {
      console.log('Notifications WebSocket connection established.');
      this.reconnectAttempts = 0;
      
      // Fetch latest notifications on reconnect to sync state
      useNotificationsStore.getState().fetchAll();
    };

    this.ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.handleMessage(message);
      } catch (error) {
        console.error('Failed to parse notification WebSocket message:', error);
      }
    };

    this.ws.onclose = (event) => {
      if (this.isIntentionalDisconnect) {
        console.log('Notifications WebSocket closed intentionally.');
        return;
      }
      
      if (event.code !== 1000) { 
        console.log(`Notifications WebSocket closed with code ${event.code}. Attempting to reconnect...`);
        this.scheduleReconnect();
      }
    };

    this.ws.onerror = (error) => {
      console.error('Notifications WebSocket error:', error);
      // Let onclose handle reconnection
    };
  }
  
  private handleMessage(message: { type: string; payload?: any }): void {
    const { type, payload } = message;
    
    switch (type) {
      case 'patches':
        if (payload) {
          useSyncStore.getState().applyServerPatches(payload.newRev, payload.patches);
        }
        break;
        
      case 'new_notification':
        if (payload) {
          // Use the addNotification method for deduplication
          useNotificationsStore.getState().addNotification(payload);
          
          toast.info(payload.title, {
            description: payload.body,
            action: payload.action ? {
              label: 'View',
              onClick: () => window.dispatchEvent(new CustomEvent('navigate-to', { detail: payload.action }))
            } : undefined,
          });
        }
        break;
        
      case 'notifications_updated':
        // Only fetch if we didn't just make an optimistic update
        // The store handles this via optimistic updates, so we can skip refetch
        // unless it's been more than a few seconds since our last action
        useNotificationsStore.getState().fetchAll();
        break;
        
      case 'task_updated':
        useSyncStore.getState().fetchSnapshot();
        break;
        
      default:
        // Silently ignore unknown message types
        break;
    }
  }
  
  public disconnect(): void {
    this.isIntentionalDisconnect = true;
    this.cancelReconnect();
    this.cleanupConnection();
    console.log('Notifications WebSocket disconnected.');
  }
  
  private cleanupConnection(): void {
    if (this.ws) {
      this.ws.onopen = null;
      this.ws.onmessage = null;
      this.ws.onclose = null;
      this.ws.onerror = null;
      
      if (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING) {
        this.ws.close(1000, "Client disconnected");
      }
      this.ws = null;
    }
  }

  private scheduleReconnect(): void {
    if (this.isIntentionalDisconnect) {
      return;
    }
    
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.error('Max reconnection attempts reached. Giving up.');
      return;
    }
    
    this.cancelReconnect();
    
    // Exponential backoff with jitter
    const exponentialDelay = Math.min(
      this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts),
      this.maxReconnectDelay
    );
    // Add random jitter (0-25% of delay) to prevent thundering herd
    const jitter = exponentialDelay * Math.random() * 0.25;
    const delay = Math.floor(exponentialDelay + jitter);
    
    console.log(`Scheduling reconnect attempt ${this.reconnectAttempts + 1} in ${delay}ms`);
    
    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }
  
  private cancelReconnect(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }
  
  public isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN || this.isConnectedViaWebRTC;
  }
  
  public resetReconnectAttempts(): void {
    this.reconnectAttempts = 0;
  }

  // WebRTC logic would be similar to the other manager if needed
  private connectViaWebRTC(): void {
    // Implementation for WebRTC proxying would go here
    this.isConnectedViaWebRTC = true;
  }
}

const notificationsManager = NotificationsWebSocketManager.getInstance();
export default notificationsManager;